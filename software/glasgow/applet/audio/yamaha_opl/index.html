<!DOCTYPE html>
<head>
  <title>Yamaha OP* Web Gateway</title>
</head>
<body style="width:50em">
  <h1>Yamaha OP* Web Gateway</h1>
  <p>This webpage lets you submit commands to a real Yamaha synthesizer and listen to the output. The synthesizer is a <b>shared resource</b> (and isn't very fast, although it does not have to run in real time), and everyone who submits a file is in the same queue, so you might have to wait until it's your turn.</p>
  <p>Connected synthesizer: {{chip}}.</p>
  <p>Playback support for: {{compat}}.</p>
  <p><b>Glitching</b>: undervolt to <input type="number" min="1.65" max="5.50" value="5.00" step="0.01" id="voltage"></p>
  <p>Play a <a href="https://vgmrips.net/packs/chips">VGM/VGZ file</a>: <input type="file" id="file" accept=".vgm,.vgz"> <input type="button" id="play" value="Play"> <input type="button" id="replay" value="Replay" disabled> <input type="checkbox" id="loop"> <label for="loop">Loop</label></p>
  <p>Export PCM: <input type="button" id="exportFull" value="Export full" disabled> <input type="button" id="exportLoop" value="Export loop" disabled></p>
  <p>Status: <span id="chipStatus">no chip</span>, <span id="netStatus">idle</span>, <span id="playStatus">stopped</span>.</p>
  <p id="errorPane" style="color:red; display:none">Error: <span id="error"></span></p>

  <!--
    Yes, I know this code is shit. I hate Web. I hate audio. I especially hate web audio.
    Pull requests welcome.
  -->
  <script type="text/javascript">
    var BUFFER_AT_LEAST = 8;

    function PCMPlayer() {
      this.complete = false;

      this.loop = false;
      this.loopSkipTo = 0;

      this._context = new (window.AudioContext || window.webkitAudioContext);
      this._buffers = [];
      this._buffersRaw = [];

      this._queueStart = 0;
      this._queueEnd = 0;
      this._queueSize = 0;

      this._timestamp = this._context.currentTime;

      this.preferredSampleRate = function() {
        return this._context.sampleRate;
      }

      this.addSamples = function(dataView, sampleRate) {
        var audioBuffer = this._context.createBuffer(/*numOfChannels=*/1,
                                                     dataView.byteLength / 2, sampleRate);
        var f32Buffer = audioBuffer.getChannelData(0);
        for(var i = 0; i < f32Buffer.length; i++)
          f32Buffer[i] = dataView.getInt16(i * 2, /*littleEndian=*/true) / 32768;

        this._buffers.push(audioBuffer);
        this._buffersRaw.push(dataView.buffer);
        this._updateStatus();
      }

      this.getAllSamples = function() {
        return this._buffersRaw;
      }

      this.getLoopSamples = function() {
        var buffers = [];
        var skipTo = this.loopSkipTo * 2;
        var sourcePos = 0;
        for(var i = 0; i < this._buffersRaw.length; i++) {
          if(skipTo >= sourcePos + this._buffersRaw[i].byteLength) {
            // skip
          } else if(skipTo >= sourcePos) {
            buffers.push(this._buffersRaw[i].slice(skipTo - sourcePos));
          } else {
            buffers.push(this._buffersRaw[i]);
          }
          sourcePos += this._buffersRaw[i].byteLength;
        }
        return buffers;
      }

      this.scheduleAtLeast = function(atLeast) {
        if(this._buffers.length - this._queueEnd < atLeast) {
          console.log("need at least", atLeast, "buffers;",
                      "have ", this._buffers.length - this._queueEnd);
          return;
        }
        if(this._queueSize >= atLeast) return false;
        var scheduleCount = atLeast - this._queueSize;
        console.log("scheduling", scheduleCount, "buffers");
        for(var i = 0; i < scheduleCount; i++)
          this._scheduleNode();
        return true;
      }

      this._scheduleNode = function(first) {
        var skipTo = 0;
        var skipPos = 0;
        if(this._queueEnd == this._buffers.length) {
          if(this.complete && this.loop) {
            console.log("looping");
            this._queueEnd = 0;
            skipTo = this.loopSkipTo;
          } else return;
        }

        while(true) {
          var bufferOffset = 0;
          var bufferIndex = this._queueEnd++;
          var audioBuffer = this._buffers[bufferIndex];
          if(skipTo > 0 && skipPos < skipTo) {
            if(skipPos + audioBuffer.length < skipTo) {
              skipPos += audioBuffer.length;
              console.log("skipped buffer", bufferIndex, "completely");
              continue;
            } else {
              bufferOffset = audioBuffer.duration / audioBuffer.length * (skipTo - skipPos);
              skipPos = skipTo;
              console.log("skipped buffer", bufferIndex, "to position", bufferOffset);
            }
          }
          break;
        }

        var audioBufferSource = this._context.createBufferSource();
        audioBufferSource.buffer = audioBuffer;
        audioBufferSource.connect(this._context.destination);
        this._queueSize++;
        audioBufferSource.start(this._timestamp, bufferOffset);
        console.log("scheduled buffer", bufferIndex, "at", this._timestamp, ";",
                    "now", this._queueSize);

        if(this._timestamp < this._context.currentTime)
          this._timestamp = this._context.currentTime;
        this._timestamp += audioBuffer.duration;

        var player = this;
        audioBufferSource.onended = function(event) {
          player._queueSize--;
          player._queueStart = bufferIndex;
          console.log("finished buffer", bufferIndex, ";",
                      "now", player._queueSize);
          if(player.complete && bufferIndex == player._buffers.length - 1) {
            // Chromium appears to not invoke onended for some audio buffer sources for unknown
            // reasons. This appears to happen only when the console is closed (?!) and I think
            // when the page isn't in focus, and if we don't account for this, the player will
            // hang and require a page reload.
            if(!player.loop) {
              player._queueSize = 0;
            }
          }
          player._updateStatus();
          player._scheduleNode();
        }
      };

      this.rewind = function() {
        if(this._queueSize) return;

        this._queueStart = 0;
        this._queueEnd = 0;
        this._timestamp = this._context.currentTime;
      }

      this.onstatuschange = undefined;
      this._updateStatus = function() {
        if(this.onstatuschange)
          this.onstatuschange({
            playing: !!this._queueSize,
            done: this._queueStart,
            total: this._buffers.length,
          });
      }
    }

    function makeWAVFile(fileName, numOfChannels, sampleRate, bytesPerSample, sampleBuffers) {
      var totalSampleBytes = 0;
      for(var i = 0; i < sampleBuffers.length; i++)
        totalSampleBytes += sampleBuffers[i].byteLength;

      var id_length            = 8,
          fmt_subchunk_length  = id_length + 16,
          data_subchunk_length = id_length + totalSampleBytes,
          RIFF_header_length   = id_length + 4,
          RIFF_chunk_length    = RIFF_header_length + fmt_subchunk_length + data_subchunk_length;

      var header = new ArrayBuffer(RIFF_header_length + fmt_subchunk_length + id_length);
      var headerView = new DataView(header, 0, header.length);

      // "RIFF" chunk
      // ChunkID
      headerView.setUint32(0, /*"RIFF"*/0x52494646,
                              /*littleEndian=*/false);
      // ChunkSize
      headerView.setUint32(4, RIFF_chunk_length - id_length,
                              /*littleEndian=*/true);
      // Format
      headerView.setUint32(8, /*"WAVE"*/0x57415645,
                              /*littleEndian=*/false);

      // "fmt " subchunk
      // Subchunk1ID
      headerView.setUint32(12, /*"fmt "*/0x666d7420,
                              /*littleEndian=*/false);
      // Subchunk1Size
      headerView.setUint32(16, fmt_subchunk_length - id_length,
                              /*littleEndian=*/true);
      // AudioFormat
      headerView.setUint16(20, /*PCM*/1,
                              /*littleEndian=*/true);
      // NumChannels
      headerView.setUint16(22, numOfChannels,
                              /*littleEndian=*/true);
      // SampleRate
      headerView.setUint32(24, sampleRate,
                              /*littleEndian=*/true);
      // ByteRate
      headerView.setUint32(28, sampleRate * numOfChannels * bytesPerSample,
                              /*littleEndian=*/true);
      // BlockAlign
      headerView.setUint16(32, numOfChannels * bytesPerSample,
                              /*littleEndian=*/true);
      // BitsPerSample
      headerView.setUint16(34, bytesPerSample * 8,
                              /*littleEndian=*/true);

      // "data" subchunk
      // Subchunk1ID
      headerView.setUint32(36, /*"data"*/0x64617461,
                              /*littleEndian=*/false);
      // Subchunk1Size
      headerView.setUint32(40, totalSampleBytes,
                              /*littleEndian=*/true);

      return new File([header].concat(sampleBuffers), fileName, {type: "audio/wav"});
    }

    function downloadFile(file) {
      if(window.fileUrl)
        URL.revokeObjectURL(window.fileUrl);
      window.fileUrl = URL.createObjectURL(file);

      var a = window.document.createElement('a');
      a.href = window.fileUrl;
      a.download = file.name;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    }

    var voltageSpinner = document.getElementById("voltage");
    var playButton = document.getElementById("play");
    var replayButton = document.getElementById("replay");
    var exportFullButton = document.getElementById("exportFull");
    var exportLoopButton = document.getElementById("exportLoop");
    var loopCheckbox = document.getElementById("loop");
    var fileInput = document.getElementById("file");
    var netStatusSpan = document.getElementById("netStatus");
    var playStatusSpan = document.getElementById("playStatus");
    var chipStatusSpan = document.getElementById("chipStatus");
    var errorPane = document.getElementById("errorPane");
    var errorSpan = document.getElementById("error");
    playButton.onclick = function(event) {
      playButton.disabled = true;
      replayButton.disabled = true;
      exportFullButton.disabled = true;
      exportLoopButton.disabled = true;
      chipStatusSpan.innerText = "no chip";

      var player = new PCMPlayer();
      window.player = player;

      player.onstatuschange = function(event) {
        var status;
        if(event.playing) {
          status = "playing (" + event.done + "/" + event.total + " buffers)";
        } else {
          status = "stopped";
          if(player.complete && event.done == event.total - 1) {
            playButton.disabled = false;
            replayButton.disabled = false;
          }
        }
        playStatusSpan.innerText = status;
      }

      replayButton.onclick = function(event) {
        playButton.disabled = true;
        replayButton.disabled = true;

        player.rewind();
        player.scheduleAtLeast(BUFFER_AT_LEAST);
      }

      player.loop = loopCheckbox.checked;
      loopCheckbox.onchange = function(event) {
        player.loop = loopCheckbox.checked;
      }

      var socketUrl = new URL("/vgm", window.location.href);
      socketUrl.protocol = socketUrl.protocol.replace("http", "ws");
      var socket = new WebSocket(socketUrl);
      socket.binaryType = "arraybuffer";
      netStatusSpan.innerText = "connecting";
      var errored = false;
      socket.onopen = function(event) {
        errored = false;
        socket.send(JSON.stringify({
          "Preferred-Sample-Rate": player.preferredSampleRate(),
          "Voltage": voltage.value,
        }));
        socket.send(fileInput.files[0]);
        netStatusSpan.innerText = "waiting";
      }
      var sampleRate = 0;
      var totalSamples = 0;
      var doneSamples = 0;
      socket.onmessage = function(event) {
        errorPane.style.display = "none";
        if(totalSamples == 0) {
          var response = JSON.parse(event.data);
          sampleRate = response["Sample-Rate"];
          totalSamples = response["Total-Samples"];
          player.loopSkipTo = response["Loop-Skip-To"];
          chipStatusSpan.innerText = "chip " + response["Chip"];
        } else {
          var view = new DataView(new Uint8Array(event.data).buffer);
          doneSamples += view.byteLength / 2;
          player.addSamples(view, sampleRate);
          if(!player._playing)
            player.scheduleAtLeast(BUFFER_AT_LEAST);
          netStatusSpan.innerText = "streaming " + Math.floor(doneSamples / totalSamples * 100) +
            "% (" + doneSamples + "/" + totalSamples + " samples)";
        }
      }
      socket.onerror = function(event) {
        errored = true;
      }
      socket.onclose = function(event) {
        if(errored || event.code != 1000) {
          playButton.disabled = false;
          errorPane.style.display = "";
          errorSpan.innerText = event.reason || "WebSocket connection failed";
          netStatusSpan.innerText = "error";
        } else {
          player.complete = true;
          exportFullButton.disabled = false;
          if(player.loopSkipTo > 0)
            exportLoopButton.disabled = false;
          netStatusSpan.innerText = "done " + Math.floor(doneSamples / totalSamples * 100) +
            "% (" + doneSamples + "/" + totalSamples + " samples)";
        }
      }

      exportFullButton.onclick = function(event) {
        var fileName = fileInput.files[0].name.replace(/\.vg[mz]$/i, "") + ".wav";
        downloadFile(makeWAVFile(fileName, /*numOfChannels=*/1, sampleRate, /*bytesPerSample=*/2,
                                 player.getAllSamples()));
      }
      exportLoopButton.onclick = function(event) {
        var fileName = fileInput.files[0].name.replace(/\.vg[mz]$/i, "") + " (loop).wav";
        downloadFile(makeWAVFile(fileName, /*numOfChannels=*/1, sampleRate, /*bytesPerSample=*/2,
                                 player.getLoopSamples()));
      }
    };
  </script>
</body>
